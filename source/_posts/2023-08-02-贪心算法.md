---
title: 贪心算法
author: 高红翔
date: 2023-08-02 16:53:42
categories: LeetCode
tags:
  - 贪心算法
---

## 455. 分发饼干

### 题目

力扣（LeetCode） 链接：https://leetcode.cn/problems/assign-cookies/

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释:
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释:
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

**提示：**

- `1 <= g.length <= 3 * 104`
- `0 <= s.length <= 3 * 104`
- `1 <= g[i], s[j] <= 231 - 1`

### 解析

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function (g, s) {
  g.sort((a, b) => a - b)
  s.sort((a, b) => a - b)
  let i = 0,
    j = 0
  let res = 0
  while (i < g.length && j < s.length) {
    if (s[j] >= g[i]) {
      res++
      i++
      j++
    } else {
      j++
    }
  }
  return res
}
```

## 376. 摆动序列

### 题目

力扣（LeetCode） 链接：https://leetcode.cn/problems/combination-sum/

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

### 解析

```js
var wiggleMaxLength = function (nums) {
  // 边界条件,数组长度小于等于1直接返回长度
  if (nums.length <= 1) return nums.length

  let result = 1 // 记录摆动序列的长度,默认为1

  let preDiff = 0 // 前一对差值
  let curDiff = 0 // 当前一对差值

  // 从 0 到长度 - 1,两两比较元素大小
  for (let i = 0; i < nums.length - 1; i++) {
    curDiff = nums[i + 1] - nums[i] // 计算当前一对的差值

    // 如果当前一对差值符号与前一对不同,更新摆动序列长度
    if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
      result++
      preDiff = curDiff
    }
  }

  return result
}

/**
 * 核心思路:
 * 1. 计算出相邻元素的差值
 * 2. 如果前后差值符号不同,表示摆动,更新序列长度
 * 3. 返回最后得到的摆动序列的最大长度
 */
```

### 思考

- 怎么判断到达定点
- 怎么删除多余的数据

## 摆动序列-376

### 题目

力扣（LeetCode） 链接：https://leetcode.cn/problems/combination-sum/

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

### 解析

```js
var wiggleMaxLength = function (nums) {
  // 边界条件,数组长度小于等于1直接返回长度
  if (nums.length <= 1) return nums.length

  let result = 1 // 记录摆动序列的长度,默认为1

  let preDiff = 0 // 前一对差值
  let curDiff = 0 // 当前一对差值

  // 从 0 到长度 - 1,两两比较元素大小
  for (let i = 0; i < nums.length - 1; i++) {
    curDiff = nums[i + 1] - nums[i] // 计算当前一对的差值

    // 如果当前一对差值符号与前一对不同,更新摆动序列长度
    if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
      result++
      preDiff = curDiff
    }
  }

  return result
}

/**
 * 核心思路:
 * 1. 计算出相邻元素的差值
 * 2. 如果前后差值符号不同,表示摆动,更新序列长度
 * 3. 返回最后得到的摆动序列的最大长度
 */
```

### 思考

- 怎么判断到达定点
- 怎么删除多余的数据

## 最大子数组和 - 53

### 题目

力扣（LeetCode） 链接：https://leetcode.cn/problems/maximum-subarray/

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

### 解析

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  let max = nums[0] //默认第一项最大
  let res = nums[0] //截止前一项的最大值
  for (var i = 1; i < nums.length; i++) {
    res = Math.max(nums[i], res + nums[i]) // 计算下一项的最大值
    max = Math.max(max, res) //最终的比较
  }

  return max
}
```

## 买卖股票的最佳时机 II - 122

### 题目

力扣（LeetCode） 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/

- 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

  在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

  返回 _你能获得的 **最大** 利润_ 。

  **示例 1：**

  ```
  输入：prices = [7,1,5,3,6,4]
  输出：7
  解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
       随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
       总利润为 4 + 3 = 7 。
  ```

  **示例 2：**

  ```
  输入：prices = [1,2,3,4,5]
  输出：4
  解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
       总利润为 4 。
  ```

  **示例 3：**

  ```
  输入：prices = [7,6,4,3,1]
  输出：0
  解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
  ```

  **提示：**

  - `1 <= prices.length <= 3 * 104`
  - `0 <= prices[i] <= 104`

### 解析

```js
var maxProfit = function (prices) {
  let res = 0

  for (let i = 0; i < prices.length - 1; i++) {
    res += Math.max(0, prices[i + 1] - prices[i])
  }

  return res
}
```
