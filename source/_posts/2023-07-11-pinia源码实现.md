---
title: piniaæºç å®ç°
author: é«˜çº¢ç¿”
date: 2023-07-11 23:07:00
categories: å‰ç«¯æ¡†æ¶
tags: Vue.js
---

ä»£ç åœ°å€ï¼š

- https://github.com/ghx9908/pinia

- https://pinia.vuejs.org/

- https://github.com/vuejs/pinia

## ä¸€ã€Pinia çš„ä¼˜åŠ¿

1. æ›´ç®€å•çš„ä½¿ç”¨æ–¹å¼,é€šè¿‡ç»„åˆå¼å‡½æ•°(compose APIs)è½»æ¾åˆ›å»º storeã€‚
2. æ¨¡å—åŒ– stores,æ¯ä¸ªé¡µé¢ä¸€ä¸ª store,ä¸éœ€è¦æ‰‹åŠ¨æ³¨å†Œå’Œæ³¨å…¥ã€‚
3. å»ä¸­å¿ƒåŒ–çŠ¶æ€ç®¡ç†,ç»„ä»¶å¯ä»¥ç›´æ¥å¼•ç”¨éœ€è¦çš„ storeã€‚
4. [æ”¯æŒ Vue devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)è°ƒè¯•
5. çµæ´»çš„ store ç»“æ„,state å¯ä»¥æ˜¯å‡½æ•°æˆ–è€…å¯¹è±¡ã€‚
6. åŒæ­¥æˆ–å¼‚æ­¥çš„ actionsã€‚
7. æ— éœ€æ‰‹åŠ¨æ·»åŠ æ¨¡å—,store è‡ªåŠ¨æ‹†åˆ†æˆå¤šä¸ªæ¨¡å—ã€‚
8. å®Œæ•´çš„ TypeScript æ”¯æŒã€‚

## äºŒã€Pinia çš„åŸºæœ¬ä½¿ç”¨

### 1.å®‰è£… Pinia

```bash
npm install pinia
```

### 2.ä½¿ç”¨æ’ä»¶

```js
import { createPinia } from "pinia"
const app = createApp(App)
app.use(createPinia()).mount("#app") // ä½¿ç”¨æ’ä»¶ç®¡ç†æ‰€æœ‰çŠ¶æ€
```

### 3.å®šä¹‰ store

> stores/counter.js

```js
import { defineStore } from "pinia"
export const useCounterStore = defineStore("main", {
  state: () => ({ count: 0 }), // å®¹å™¨ä¸­çš„çŠ¶æ€
  actions: {
    increment() {
      this.count++ // actionä¸­æ›´æ”¹çŠ¶æ€
    },
  },
})
```

### 4.ç»„ä»¶ä½¿ç”¨

```vue
<template>
  {{ store.count }}
  <button @click="handleClick">ä¿®æ”¹çŠ¶æ€</button>
</template>

<script setup>
import { useCounterStore } from "@/stores/counter"
const store = useCounterStore()
const handleClick = () => {
  store.increment()
}
</script>
```

## ä¸‰ã€ç°æ ¸å¿ƒ Pinia

> pinia/index.js

```js
export { createPinia } from "./createPinia"
export { defineStore } from "./store"
```

### 1.å®ç° createPinia

> è¿™æ˜¯ Pinia çš„æ ¸å¿ƒå®ç°,åˆ›å»º pinia å®ä¾‹,æä¾›å…¨å±€çŠ¶æ€å®¹å™¨å’Œæ–¹æ³•,ç”¨äºåç»­åˆ›å»ºå’Œç®¡ç† stores,å®ç°æ•´ä¸ªçŠ¶æ€ç®¡ç†

1. åˆ›å»ºä¸€ä¸ª effect ä½œç”¨åŸŸ scope,ç”¨äºå­˜å‚¨å…¨å±€çŠ¶æ€ã€‚
2. åœ¨ scope å†…ä½¿ç”¨ ref åˆ›å»ºä¸€ä¸ªç©ºçš„å…±äº«çŠ¶æ€ stateã€‚
3. åˆ›å»º pinia å®ä¾‹,åŒ…å«å¤šä¸ªå±æ€§å’Œæ–¹æ³•ã€‚
4. install æ–¹æ³•åœ¨ app ä¸­æ³¨å†Œ pinia,æä¾›å…¨å±€å®ä¾‹,å¹¶è®¾ç½®å½“å‰æ¿€æ´»çš„å®ä¾‹ã€‚
5. state ä¸ºå…¨å±€å…±äº«çš„ç©ºçŠ¶æ€ã€‚
6. use æ–¹æ³•ç”¨äºä½¿ç”¨æ’ä»¶ã€‚
7. \_p å­˜å‚¨ä½¿ç”¨çš„æ’ä»¶åˆ—è¡¨ã€‚
8. \_a å­˜å‚¨å½“å‰çš„åº”ç”¨å®ä¾‹ã€‚
9. \_e å­˜å‚¨å…±äº«çš„ effect ä½œç”¨åŸŸã€‚
10. \_s å­˜å‚¨æ³¨å†Œçš„ storesã€‚
11. é€šè¿‡ createPinia åˆ›å»ºå‡º pinia å®ä¾‹,å¹¶åœ¨ app ä¸­æ³¨å†Œä½¿ç”¨ã€‚
12. åç»­é€šè¿‡ defineStore æ³¨å†Œ store æ—¶ä¼šå¾€ state ä¸­æ·»åŠ æ•°æ®ã€‚
13. é€šè¿‡ provide/inject æ–¹å¼åœ¨å…¨å±€æä¾› pinia å®ä¾‹ã€‚

```js
import { ref, effectScope } from "vue"

export const piniaSymbol = Symbol()
export let activePinia
export const setActivePinia = (pinia) => (activePinia = pinia)

export function createPinia() {
  const scope = effectScope()
  // æ•´ä¸ªåº”ç”¨çš„çŠ¶æ€ç¨ådefineStoreçš„æ—¶å€™ å°±ä¼šåœ¨è¿™é‡Œå¢åŠ çŠ¶æ€
  const state = scope.run(() => ref({}))
  let _p = []
  const pinia = {
    install(app) {
      pinia._a = app // å½“å‰åº”ç”¨
      setActivePinia(pinia) // è®¾ç½®æ¿€æ´»pinia
      // 1.åœ¨å½“å‰åº”ç”¨ä¸­æš´éœ²piniaå®ä¾‹
      app.provide(piniaSymbol, pinia)
      // 2.optionsAPIå¯ä»¥é€šè¿‡thisè®¿é—®åˆ°å®ä¾‹
      app.config.globalProperties.$pinia = pinia
    },
    state,
    use(plugin) {
      //  ä½¿ç”¨æ’ä»¶
      _p.push(plugin)
      return //å¯ä»¥é“¾å¼è°ƒç”¨
    },
    _p, //è®°å½•ä½¿ç”¨çš„æ’ä»¶
    _a: null, //è®°å½•å½“å‰çš„app
    _e: scope, // å½“å‰ä½œç”¨åŸŸ
    _s: new Map(), // è®°å½•æœ‰å“ªäº›storeçš„
  }
  return pinia
}
```

### 2.å®ç° defineStore

> defineStore æ˜¯ Pinia çš„æ ¸å¿ƒæ–¹æ³•ï¼Œç”¨æ¥å®šä¹‰ä¸€ä¸ªæ–°çš„ store å¹¶è¿”å›è·å–è¯¥ store çš„å‡½æ•°ã€‚å®ƒä¼šåœ¨ pinia ä¸­æ³¨å†Œè¯¥ storeï¼Œå¹¶ç®¡ç† store çš„åˆ›å»ºã€‚è°ƒç”¨ defineStore å¾—åˆ°çš„ useStore å‡½æ•°å¯ä»¥ç”¨æ¥åœ¨ç»„ä»¶ä¸­è·å–å¹¶ä½¿ç”¨è¯¥ storeã€‚
>
> è¿™æ ·å®ç°äº†å­˜å‚¨çš„æ¨¡å—åŒ–æ³¨å†Œ,ä»¥åŠé€šè¿‡ useStore ç»„åˆå¼è·å– store å®ä¾‹ã€‚æ˜¯ Pinia çŠ¶æ€ç®¡ç†çš„å…³é”®ã€‚

1. ä»å‚æ•°ä¸­æå– store çš„ id å’Œ optionsã€‚
2. å®šä¹‰ useStore å‡½æ•°,ç”¨äºè·å– store å®ä¾‹ã€‚
3. åœ¨ useStore ä¸­,é€šè¿‡ pinia å®ä¾‹è·å– storeã€‚
4. å¦‚æœ store æœªåˆ›å»º,ä¼šæ ¹æ®ä¼ å…¥çš„ setup æˆ– options åˆ›å»ºæ–°çš„ storeã€‚
5. createSetupStore å’Œ createOptionsStore åˆ†åˆ«å¤„ç† setup store å’Œ options storeã€‚
6. åˆ›å»ºå¥½çš„ store ä¼šå­˜å…¥ pinia.\_s ä¸­ã€‚
7. useStore å‡½æ•°è¿”å›å·²ç»åˆ›å»ºçš„ store å®ä¾‹ã€‚
8. ç»™ useStore æ·»åŠ  $id å±æ€§,ç»‘å®š store idã€‚
9. defineStore è¿”å› useStore å‡½æ•°ã€‚

```js
export function defineStore(idOrOptions, setup, setupOptions = {}) {
  // idä»å­—ç¬¦ä¸²æˆ–é…ç½®å¯¹è±¡ä¸­æå–
  let id
  let options
  const isSetupStore = typeof setup === "function"
  // æ ¹æ®æƒ…å†µåˆ†åˆ«è®¾ç½®idå’Œoptions
  if (typeof idOrOptions === "string") {
    id = idOrOptions
    options = isSetupStore ? setupOptions : setup
  } else {
    options = idOrOptions
    id = idOrOptions.id
  }
  // å®šä¹‰useStoreå‡½æ•°
  function useStore() {
    // åˆ¤æ–­æ˜¯å¦å­˜åœ¨piniaä¸Šä¸‹æ–‡ç¯å¢ƒ
    const hasContext = hasInjectionContext()
    // ä»contextä¸­è¯»å– pinia å®ä¾‹
    // åªèƒ½åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
    let pinia = hasContext && inject(piniaSymbol)
    if (pinia) setActivePinia(pinia)
    pinia = activePinia
    // å¦‚æœè¯¥storeå°šæœªåˆ›å»º
    if (!pinia._s.has(id)) {
      // æ ¹æ®æƒ…å†µåˆ›å»ºstore,å­˜å‚¨åˆ°_sä¸­
      if (isSetupStore) {
        createSetupStore(id, setup, {}, pinia, true) // åˆ›å»ºsetupStore
      } else {
        createOptionsStore(id, options, pinia, false) // åˆ›å»ºé€‰é¡¹store
      }
    }
    // å–å‡ºå·²åˆ›å»ºçš„storeè¿”å›
    const store = pinia._s.get(id)
    return store
  }
  // ç»™å‡½æ•°ç»‘å®šstoreçš„id
  useStore.$id = id
  // è¿”å›useStoreå‡½æ•°
  return useStore
}
```

### 3.åˆ›å»º setupStore

> è¿™æ ·é€šè¿‡ effect ä½œç”¨åŸŸå’Œ reactive,å®ç°äº† setup è¯­æ³•çš„ Pinia store å®šä¹‰æ–¹å¼,åŒæ—¶æ·»åŠ äº† actions æ”¯æŒã€‚
> å¹¶é€šè¿‡ pinia ç®¡ç†æ‰€æœ‰çš„ storesã€‚è¿™æ˜¯ Pinia ä¸­å®ç°ç»„ä»¶åŒ–çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒæœºåˆ¶ã€‚

1. åˆ›å»ºä¸€ä¸ªæ–°çš„ effect ä½œç”¨åŸŸ scope,ç”¨äºéš”ç¦»è¿™ä¸ª store çš„çŠ¶æ€ã€‚
2. å®šä¹‰ä¸€ä¸ª wrapAction æ–¹æ³•,ç”¨äºåŒ…è£… actions å‡½æ•°,æ”¹å˜ this æŒ‡å‘ store æœ¬èº«ã€‚
3. åˆ›å»ºä¸€ä¸ª partialStore å¯¹è±¡,åŒ…å« pinia å®ä¾‹å’Œ id ä¿¡æ¯ã€‚
4. ä½¿ç”¨ reactive å°† partialStore è½¬æ¢æˆå“åº”å¼ã€‚
5. åœ¨ pinia.\_e ä½œç”¨åŸŸå†…è¿è¡Œ setup å‡½æ•°,è¿”å›åˆå§‹åŒ–çš„çŠ¶æ€ã€‚
6. ä½¿ç”¨ for å¾ªç¯éå† setupStore,å¦‚æœæ˜¯å‡½æ•°å°±ç”¨ wrapAction åŒ…è£…æˆ actionã€‚
7. ä½¿ç”¨ Object.assign å°† setupStore åˆå¹¶åˆ° store ä¸­ã€‚
8. å°†å®šä¹‰å¥½çš„ store ä¿å­˜åˆ° pinia çš„ store å®¹å™¨ pinia.\_s ä¸­ã€‚
9. è¿”å›åˆ›å»ºå¥½çš„ store å®ä¾‹ã€‚

```js
function createSetupStore($id, setup, options, pinia, isSetupStore) {
  let scope
  if (isSetupStore) {
    pinia.state.value[$id] = {}
  }
  //å¤„ç†action ä¿®æ”¹thisæŒ‡å‘
  function wrapAction(name, action) {
    // action
    return function () {
      let ret = action.apply(this, arguments) // è®©thisæŒ‡å‘store
      return ret
    }
  }

  const partialStore = {
    _p: pinia,
    $id,
  }

  let store = reactive(partialStore)
  const setupStore = pinia._e.run(() => {
    scope = effectScope() // éœ€è¦å¼€è¾Ÿä¸€ä¸ªç©ºé—´ï¼Œæ¥ç®¡ç†æ­¤storeä¸­çš„æ•°æ®
    return scope.run(() => setup()) // è¿™ä¸ªsetupæ–¹æ³•å°±æ˜¯ç”¨æ¥åˆå§‹åŒ–storeä¸­çš„çŠ¶æ€çš„
  })
  //overwrite existing actions to support $onAction
  for (const key in setupStore) {
    const prop = setupStore[key]
    // pinia.state.value[$id] æå–state
    if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {
      if (isSetupStore) {
        pinia.state.value[$id][key] = prop
      }
    } else if (typeof prop === "function") {
      // å¯¹actionè¿›è¡Œä¸€æ¬¡åŒ…è£…
      setupStore[key] = wrapAction(key, prop)
    }
  }
  Object.assign(store, setupStore) // åˆå¹¶é€‰é¡¹

  pinia._s.set($id, store) // æ”¾å…¥åˆ°å®¹å™¨ä¸­
  return store
}
```

### 4.åˆ›å»º optionsStore

1. æŒ‰ç…§ä¼ ç»Ÿçš„ options æ–¹å¼å®šä¹‰çŠ¶æ€ã€getterã€actionã€‚
2. åœ¨ setup ä¸­åˆå¹¶ä¸åŒé€‰é¡¹åˆ°ä¸€èµ·ã€‚
3. é€šè¿‡ createSetupStore æœ€ç»ˆåˆ›å»º storeã€‚

```js
function createOptionsStore(id, options, pinia, isSetupStore) {
  let store
  //1. ä» options ä¸­è§£æ„å‡º stateã€gettersã€actionsã€‚
  const { state, getters = {}, actions = {} } = options
  //2. å®šä¹‰ setup å‡½æ•°,ç”¨äºåˆå§‹åŒ– storeã€‚
  function setup() {
    //3. æŠŠçŠ¶æ€ state ä¿å­˜åˆ° pinia çš„å…±äº«çŠ¶æ€ä¸­ã€‚
    pinia.state.value[id] = state ? state() : {}
    //4. ä½¿ç”¨ toRefs å°†stateå˜æˆå“åº”å¼
    const localState = toRefs(pinia.state.value[id])
    // 5. stateã€actionsã€getters åˆå¹¶åˆ°ä¸€èµ·è¿”å›ã€‚
    return Object.assign(
      localState,
      actions,
      //6. getters é€šè¿‡ computed è½¬æ¢æˆè®¡ç®—å±æ€§è®¿é—®ã€‚
      Object.keys(getters).reduce((gettersObj, getterName) => {
        gettersObj[getterName] = computed(() => {
          return getters[getterName].call(store)
        })
        return gettersObj
      }, {})
    )
  }
  // 7. ä½¿ç”¨ createSetupStore åˆ›å»º store,ä¼ å…¥ setupã€‚
  store = createSetupStore(id, setup, options, pinia, isSetupStore)
  //8. è¿”å›åˆ›å»ºçš„ storeã€‚
  return store
}
```

## å››ã€æ ¸å¿ƒæ–¹æ³•å’Œå±æ€§

- `$patch`:ä½¿ç”¨$patch æ–¹æ³•åŒæ—¶åº”ç”¨å¤šä¸ªä¿®æ”¹
- `$reset`: ä½¿ç”¨$reset() æ–¹æ³•å°† state é‡ç½®ä¸ºåˆå§‹å€¼
- `$subscribe`: é€šè¿‡ store çš„ $subscribe() æ–¹æ³•ä¾¦å¬ state åŠå…¶å˜åŒ–
- `$onActions`: é€šè¿‡ store.$onAction() æ¥ç›‘å¬ action å’Œå®ƒä»¬çš„ç»“æœ
- `$dispose`: åœæ­¢å“åº”
- `$state`: æ›¿æ¢ stateï¼Œé€šè¿‡å˜æ›´ pinia å®ä¾‹çš„ state æ¥è®¾ç½®æ•´ä¸ªåº”ç”¨çš„åˆå§‹ state

```diff
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
+   $reset,
+   $patch,

+    $subscribe(callback, options = {}) {
+      scope.run(() =>
+        watch(
+          pinia.state.value[$id],
+         (state) => {
+            callback({ storeId: $id }, state)
+          },
+          options
+        )
+      )
+    },
+    $onAction: addSubscription.bind(null, actionSubscriptions), // ç»‘å®šaction
+    $dispose() {
+      scope.stop() // åœç”¨store
+      actionSubscriptions = []
+      pinia._s.delete($id)
+    },
  }
```

### 1. $patch

> ä½¿ç”¨$patch æ–¹æ³•åŒæ—¶åº”ç”¨å¤šä¸ªä¿®æ”¹

```js
const store = useCounterStore()
const handleClick = () => {
  store.$patch({ count: 100 })
}
```

**å®ç°**

> $patch å‡½æ•°åˆ©ç”¨è¿™ä¸ªå®ç°äº†å¯¹ pinia çŠ¶æ€çš„éƒ¨åˆ†æ›´æ–°ã€‚

1. å¦‚æœæ˜¯å‡½æ•°,ä¼ å…¥çŠ¶æ€æ‰§è¡Œã€‚
2. å¦‚æœæ˜¯å¯¹è±¡,è°ƒç”¨ mergeReactiveObjects åˆå¹¶ã€‚

```js
const $patch = function $patch(partialStateOrMutator) {
  if (typeof partialStateOrMutator === "function") {
    partialStateOrMutator(pinia.state.value[$id])
  } else {
    mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator)
  }
}
```

**mergeReactiveObjects å‡½æ•°**

1. å¦‚æœ target å’Œ patch éƒ½æ˜¯ Map,åˆ™ç”¨ patch çš„é”®å€¼æ›´æ–° targetã€‚
2. å¦‚æœ target å’Œ patch éƒ½æ˜¯ Set,åˆ™ç”¨ patch çš„å€¼æ‰©å±• targetã€‚
3. éå† patch çš„é”®å€¼ã€‚
4. å¦‚æœé”®å­˜åœ¨äº target,ä¸”éƒ½æ˜¯æ™®é€šå¯¹è±¡,è°ƒç”¨è‡ªèº«é€’å½’åˆå¹¶ã€‚
5. å¦åˆ™ç›´æ¥ç”¨ patch çš„é”®å€¼è¦†ç›– targetã€‚
6. è¿”å›åˆå¹¶åçš„ targetã€‚

è¿™æ ·å¯ä»¥æ·±å±‚åˆå¹¶ä¸¤ä¸ªå“åº”å¼å¯¹è±¡,å¹¶ä¿æŒå“åº”æ€§ã€‚

```js
export function isPlainObject(o) {
  return (
    o &&
    typeof o === "object" &&
    Object.prototype.toString.call(o) === "[object Object]" &&
    typeof o.toJSON !== "function"
  )
}

function mergeReactiveObjects(target, patchToApply) {
  // Handle Map instances
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value))
  }
  // Handle Set instances
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target)
  }

  // no need to go through symbols because they cannot be serialized anyway
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key)) continue

    const subPatch = patchToApply[key]
    const targetValue = target[key]
    if (
      isPlainObject(targetValue) &&
      isPlainObject(subPatch) &&
      target.hasOwnProperty(key) &&
      !isRef(subPatch) &&
      !isReactive(subPatch)
    ) {
      target[key] = mergeReactiveObjects(targetValue, subPatch)
    } else {
      target[key] = subPatch
    }
  }

  return target
}
```

### 2. $reset

> ä½¿ç”¨$reset() æ–¹æ³•å°† state é‡ç½®ä¸ºåˆå§‹å€¼
>
> æ­¤æ–¹æ³•åªèƒ½åœ¨é setup è¯­æ³•ä¸­ä½¿ç”¨

```js
const handleClick = () => {
  store.$reset() // æ­¤æ–¹æ³•åªèƒ½åœ¨ésetupè¯­æ³•ä¸­ä½¿ç”¨
}
```

**å®ç°**

```js
const $reset = !isSetupStore
  ? function $reset() {
      const { state } = options
      const newState = state ? state() : {}
      // we use a patch to group all changes into one single subscription
      this.$patch(($state) => {
        Object.assign($state, newState)
      })
    }
  : () => {
      throw new Error(
        `ğŸ: Store "${$id}" is built using the setup syntax and does not implement $reset().`
      )
    }
```

### 3. $subscribe

```js
store.$subscribe(({ storeId }, state) => {
  localStorage.setItem(storeId, JSON.stringify(state))
})
```

> ç›‘å¬çŠ¶æ€å˜åŒ–ï¼ŒçŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ä¼šæ‰§è¡Œè®¢é˜…çš„å‡½æ•°

```js
const partialStore = {
  $patch,
  $subscribe(callback, options = {}) {
    scope.run(() =>
      watch(
        pinia.state.value[$id],
        (state) => {
          callback({ storeId: $id }, state)
        },
        options
      )
    )
  },
}
```

### 4. $dispose

> åœæ­¢å“åº”

```js
const partialStore = {
  $patch,
  $dispose() {
    scope.stop() // åœç”¨store
    actionSubscriptions = []
    pinia._s.delete($id)
  },
}
```

### 5.$state

```js

  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        Object.assign($state, state)
      })
    },
  })
```

### 6. $onActions

> é€šè¿‡ store.$onAction() æ¥ç›‘å¬ action å’Œå®ƒä»¬çš„ç»“æœ

```js
const handleClick = () => {
  store.increment()
}
store.$onAction(({after,onError,name})=>{
  console.log('action running~~~',name);
  after((result)=>{ // actionæ‰§è¡Œå®Œæ¯•åè§¦å‘
    console.log(result);
  })
  onError((err)=>{  // actionå‡ºé”™æ—¶è°ƒç”¨
    console.warn('error',err)
  })
})
```

**å®ç° ï¼šæ ¸å¿ƒå‘å¸ƒè®¢é˜…**

```js
function createSetupStore($id, setup, options, pinia, isSetupStore) {
    let actionSubscriptions = []
      //å¤„ç†action ä¿®æ”¹thisæŒ‡å‘
  function wrapAction(name, action) {
    // increment,action
    return function () {
      const afterCallbackList = [] // afterList
      const onErrorCallbackList = [] // errList
      function after(callback) {
        afterCallbackList.push(callback)
      }
      function onError(callback) {
        onErrorCallbackList.push(callback)
      }
      triggerSubscriptions(actionSubscriptions, { name, store, after, onError })
      let ret
      try {
        ret = action.apply(this, arguments) // è®©thisæŒ‡å‘store
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error)
      }
      if (ret instanceof Promise) {
        // è¿”å›å€¼æ˜¯promise
        return ret
          .then((value) => {
            triggerSubscriptions(afterCallbackList, value)
            return value // æˆåŠŸåè§¦å‘after
          })
          .catch((error) => {
            // å¤±è´¥åˆ™è§¦å‘error
            triggerSubscriptions(onErrorCallbackList, error)
            return Promise.reject(error)
          })
      }
      return ret
    }
  }
  
   const partialStore = {
    _p: pinia,
    $reset,
    $patch,
    $onAction: addSubscription.bind(null, actionSubscriptions), // ç»‘å®šaction
  }
}


```

**å‘å¸ƒè®¢é˜…**

```js
export function addSubscription(subscriptions, callback) {
  // æ·»åŠ è®¢é˜…
  subscriptions.push(callback);
  const removeSubcription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
    }
  };
  return removeSubcription;
}
export function triggerSubscriptions(subscriptions, ...args) {
  // è§¦å‘è®¢é˜…
  subscriptions.slice().forEach((cb) => cb(...args));
}

```



### **å®Œæ•´ä»£ç **

```js
import {
  inject,
  hasInjectionContext,
  effectScope,
  toRefs,
  computed,
  isRef,
  reactive,
  isReactive,
  watch,
} from "vue"
import { piniaSymbol } from "./rootStore"
import { addSubscription, triggerSubscriptions } from "./subscriptions"
import { setActivePinia, activePinia } from "./createPinia"
function isComputed(o) {
  return !!(isRef(o) && o.effect)
}
export function isPlainObject(o) {
  return (
    o &&
    typeof o === "object" &&
    Object.prototype.toString.call(o) === "[object Object]" &&
    typeof o.toJSON !== "function"
  )
}
function mergeReactiveObjects(target, patchToApply) {
  // Handle Map instances
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value))
  }
  // Handle Set instances
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target)
  }

  // no need to go through symbols because they cannot be serialized anyway
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key)) continue

    const subPatch = patchToApply[key]
    const targetValue = target[key]
    if (
      isPlainObject(targetValue) &&
      isPlainObject(subPatch) &&
      target.hasOwnProperty(key) &&
      !isRef(subPatch) &&
      !isReactive(subPatch)
    ) {
      target[key] = mergeReactiveObjects(targetValue, subPatch)
    } else {
      target[key] = subPatch
    }
  }

  return target
}

// id + options
// options ={id:''}
// id + setup

// å®šä¹‰ä¸€ä¸ª store å¹¶å¯¼å‡º useStore å‡½æ•°
// useStore å‡½æ•°çš„ä½œç”¨æ˜¯:
// - çœ‹æ˜¯å¦æœ‰piniaå®ä¾‹
// - å¦‚æœè¯¥storeå°šæœªåˆ›å»º,åˆ™åˆ›å»º
// - å–å‡ºå·²åˆ›å»ºçš„storeè¿”å›

export function defineStore(idOrOptions, setup, setupOptions = {}) {
  // idä»å­—ç¬¦ä¸²æˆ–é…ç½®å¯¹è±¡ä¸­æå–
  let id
  let options
  const isSetupStore = typeof setup === "function"
  // æ ¹æ®æƒ…å†µåˆ†åˆ«è®¾ç½®idå’Œoptions
  if (typeof idOrOptions === "string") {
    id = idOrOptions
    options = isSetupStore ? setupOptions : setup
  } else {
    options = idOrOptions
    id = idOrOptions.id
  }
  // å®šä¹‰useStoreå‡½æ•°
  function useStore() {
    // åˆ¤æ–­æ˜¯å¦å­˜åœ¨piniaä¸Šä¸‹æ–‡ç¯å¢ƒ
    const hasContext = hasInjectionContext()
    // ä»contextä¸­è¯»å– pinia å®ä¾‹
    // åªèƒ½åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
    let pinia = hasContext && inject(piniaSymbol)
    if (pinia) setActivePinia(pinia)
    pinia = activePinia
    // å¦‚æœè¯¥storeå°šæœªåˆ›å»º
    if (!pinia._s.has(id)) {
      // æ ¹æ®æƒ…å†µåˆ›å»ºstore,å­˜å‚¨åˆ°_sä¸­
      if (isSetupStore) {
        createSetupStore(id, setup, {}, pinia, true) // åˆ›å»ºsetupStore
      } else {
        createOptionsStore(id, options, pinia, false) // åˆ›å»ºé€‰é¡¹store
      }
    }
    // å–å‡ºå·²åˆ›å»ºçš„storeè¿”å›
    const store = pinia._s.get(id)
    return store
  }
  // ç»™å‡½æ•°ç»‘å®šstoreçš„id
  useStore.$id = id
  // è¿”å›useStoreå‡½æ•°
  return useStore
}

// optionsapi
function createOptionsStore(id, options, pinia, isSetupStore) {
  let store
  const { state, getters = {}, actions = {} } = options
  function setup() {
    // æ ¹æ®ç”¨æˆ·çš„çŠ¶æ€å°†å…¶ä¿å­˜åˆ°piniaä¸­
    pinia.state.value[id] = state ? state() : {}
    const localState = toRefs(pinia.state.value[id])
    return Object.assign(
      localState,
      actions,
      Object.keys(getters).reduce((gettersObj, getterName) => {
        gettersObj[getterName] = computed(() => {
          return getters[getterName].call(store)
        })
        return gettersObj
      }, {})
    )
  }
  store = createSetupStore(id, setup, options, pinia, isSetupStore)
  return store
}

function createSetupStore($id, setup, options, pinia, isSetupStore) {
  let scope
  let actionSubscriptions = []
  if (isSetupStore) {
    pinia.state.value[$id] = {}
  }
  //å¤„ç†action ä¿®æ”¹thisæŒ‡å‘
  function wrapAction(name, action) {
    // increment,action
    return function () {
      const afterCallbackList = [] // afterList
      const onErrorCallbackList = [] // errList
      function after(callback) {
        afterCallbackList.push(callback)
      }
      function onError(callback) {
        onErrorCallbackList.push(callback)
      }
      triggerSubscriptions(actionSubscriptions, { name, store, after, onError })
      let ret
      try {
        ret = action.apply(this, arguments) // è®©thisæŒ‡å‘store
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error)
      }
      if (ret instanceof Promise) {
        // è¿”å›å€¼æ˜¯promise
        return ret
          .then((value) => {
            triggerSubscriptions(afterCallbackList, value)
            return value // æˆåŠŸåè§¦å‘after
          })
          .catch((error) => {
            // å¤±è´¥åˆ™è§¦å‘error
            triggerSubscriptions(onErrorCallbackList, error)
            return Promise.reject(error)
          })
      }
      return ret
    }
  }

  const $patch = function $patch(partialStateOrMutator) {
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id])
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator)
    }
  }
  const $reset = !isSetupStore
    ? function $reset() {
        const { state } = options
        const newState = state ? state() : {}
        console.log("newState=>", newState)
        // we use a patch to group all changes into one single subscription
        this.$patch(($state) => {
          Object.assign($state, newState)
        })
      }
    : () => {
        throw new Error(
          `ğŸ: Store "${$id}" is built using the setup syntax and does not implement $reset().`
        )
      }
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $reset,
    $patch,

    $subscribe(callback, options = {}) {
      scope.run(() =>
        watch(
          pinia.state.value[$id],
          (state) => {
            callback({ storeId: $id }, state)
          },
          options
        )
      )
    },
    $onAction: addSubscription.bind(null, actionSubscriptions), // ç»‘å®šaction
    $dispose() {
      scope.stop() // åœç”¨store
      actionSubscriptions = []
      pinia._s.delete($id)
    },
  }

  let store = reactive(partialStore)
  const setupStore = pinia._e.run(() => {
    scope = effectScope() // éœ€è¦å¼€è¾Ÿä¸€ä¸ªç©ºé—´ï¼Œæ¥ç®¡ç†æ­¤storeä¸­çš„æ•°æ®
    return scope.run(() => setup()) // è¿™ä¸ªsetupæ–¹æ³•å°±æ˜¯ç”¨æ¥åˆå§‹åŒ–storeä¸­çš„çŠ¶æ€çš„
  })
  //overwrite existing actions to support $onAction
  for (const key in setupStore) {
    const prop = setupStore[key]
    if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {
      if (isSetupStore) {
        pinia.state.value[$id][key] = prop
      }
    } else if (typeof prop === "function") {
      // å¯¹actionè¿›è¡Œä¸€æ¬¡åŒ…è£…
      setupStore[key] = wrapAction(key, prop)
    }
  }
  Object.assign(store, setupStore) // åˆå¹¶é€‰é¡¹

  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        Object.assign($state, state)
      })
    },
  })
  pinia._p.forEach((extender) => {
    Object.assign(
      store,
      scope.run(() => extender({ store, app: pinia._a, pinia }))
    )
  })

  pinia._s.set($id, store) // æ”¾å…¥åˆ°å®¹å™¨ä¸­
  return store
}

```



## äº”ã€Pluginæ’ä»¶å®ç°

**æ¡ˆä¾‹ ï¼š æŒä¹…åŒ–å­˜å‚¨æ’ä»¶** `pinia-plugin-persistedstate`

```js
//  import piniaPluginPersistedstate from "pinia-plugin-persistedstate"
const pinia = createPinia()
function plugin({ store }) {
  let id = store.$id
  console.log("store=>", store, store.$id)
  // ... æˆ‘è¦æ‹¿åˆ°æ‰€æœ‰çš„çŠ¶æ€ï¼Œ æ›¿æ¢æ‰é»˜è®¤çŠ¶æ€
  let state = JSON.parse(localStorage.getItem(id))
  if (state) {
    store.$state = state
  }
  store.$subscribe(({ storeId }, state) => {
    // æ¯ä¸ªæ’ä»¶éƒ½ä¼šæ‰§è¡Œè®¢é˜…æ“ä½œ
    localStorage.setItem(storeId, JSON.stringify(state))
  })
}

pinia.use(plugin)
```



**å®ç°**

```js
export function createPinia() {
    let _p = [];
    const pinia =({
        use(plugin){
            _p.push(plugin);
            return this;
        },
      //...
    })
    return pinia
}

```

```js
function createSetupStore($id, setup, options, pinia, isSetupStore) {
	
 //.....
    pinia._p.forEach((extender) => {
    Object.assign(
      store,
      scope.run(() => extender({ store, app: pinia._a, pinia }))
    )
  })
  //.....
  
}
```

## å…­ã€å…¶ä»–

### 1. storeToRefs

ä» Store ä¸­æå–å±æ€§åŒæ—¶ä¿æŒå…¶å“åº”å¼ï¼Œéœ€è¦ä½¿ç”¨`storeToRefs()`ã€‚

```js
import { toRaw, isRef, isReactive, toRef } from "vue"
export function storeToRefs(store) {
  store = toRaw(store)
  const refs = {}
  for (const key in store) {
    const value = store[key]
    if (isRef(value) || isReactive(value)) {
      refs[key] = toRef(store, key)
    }
  }

  return refs
}

```



### 2. mapHelpers

ç”¨æ³•

```js
 export default {
   computed:{
 	...mapState(useCounterStore,['count']), // çŠ¶æ€
    ...mapState(useCounterStore,{ // æ˜ å°„
       myCount1:'count',
       myCount2:(store)=> store.count
     }),
     ...mapState(useCounterStore,['doubleCount']) // getters
   }
 }

 export default {
   computed:{
     ...mapWritableState(useCounterStore,['count']),
     ...mapState(useCounterStore,['doubleCount'])
   },
   methods:{
     ...mapActions(useCounterStore,['increment']),
     ...mapActions(useCounterStore,{myIncrement:'increment'})
   },
 }
```



å®ç°

```js

export function mapState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper)
    ? keysOrMapper.reduce((reduced, key) => {
        // æ•°ç»„çš„å†™æ³•
        reduced[key] = function () {
          return useStore()[key]
        }
        return reduced
      }, {})
    : Object.keys(keysOrMapper).reduce((reduced, key) => {
        // å¯¹è±¡çš„å†™æ³•
        reduced[key] = function () {
          const store = useStore()
          const storeKey = keysOrMapper[key] // è·å–storeä¸­çš„å€¼

          // å¯¹è±¡ä¸­å‡½æ•°çš„å†™æ³•
          return typeof storeKey === "function"
            ? storeKey.call(this, store)
            : store[storeKey]
        }
        return reduced
      }, {})
}

export const mapGetters = mapState


export function mapActions(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper)
    ? keysOrMapper.reduce((reduced, key) => {
        reduced[key] = function (...args) {
          return useStore()[key](...args)
        }
        return reduced
      }, {})
    : Object.keys(keysOrMapper).reduce((reduced, key) => {
        // @ts-expect-error
        reduced[key] = function (...args) {
          return useStore()[keysOrMapper[key]](...args)
        }
        return reduced
      }, {})
}

```

## æ€»ç»“

> æ€»å¾—æ¥è¯´ï¼ŒPinia å°±æ˜¯ Vuex çš„æ›¿ä»£ç‰ˆï¼Œå¯ä»¥æ›´å¥½çš„å…¼å®¹ Vue2ï¼ŒVue3ä»¥åŠTypeScriptã€‚åœ¨Vuexçš„åŸºç¡€ä¸Šå»æ‰äº† Mutationï¼Œåªä¿ç•™äº† state, getterå’Œactionã€‚Piniaæ‹¥æœ‰æ›´ç®€æ´çš„è¯­æ³•ï¼Œ æ‰å¹³åŒ–çš„ä»£ç ç¼–æ’ï¼Œç¬¦åˆVue3 çš„ Composition api
