---
title: pinia源码实现
author: 高红翔
date: 2023-07-11 23:07:00
categories: 前端框架
tags: Vue.js
---

代码地址：

- https://github.com/ghx9908/pinia

- https://pinia.vuejs.org/

- https://github.com/vuejs/pinia

## Pinia 的优势

1. 更简单的使用方式,通过组合式函数(compose APIs)轻松创建 store。
2. 模块化 stores,每个页面一个 store,不需要手动注册和注入。
3. 去中心化状态管理,组件可以直接引用需要的 store。
4. [支持 Vue devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)调试
5. 灵活的 store 结构,state 可以是函数或者对象。
6. 同步或异步的 actions。
7. 无需手动添加模块,store 自动拆分成多个模块。
8. 完整的 TypeScript 支持。

## Pinia 的基本使用

### 1.安装 Pinia

```bash
npm install pinia
```

### 2.使用插件

```js
import { createPinia } from "pinia"
const app = createApp(App)
app.use(createPinia()).mount("#app") // 使用插件管理所有状态
```

### 3.定义 store

> stores/counter.js

```js
import { defineStore } from "pinia"
export const useCounterStore = defineStore("main", {
  state: () => ({ count: 0 }), // 容器中的状态
  actions: {
    increment() {
      this.count++ // action中更改状态
    },
  },
})
```

### 4.组件使用

```vue
<template>
  {{ store.count }}
  <button @click="handleClick">修改状态</button>
</template>

<script setup>
import { useCounterStore } from "@/stores/counter"
const store = useCounterStore()
const handleClick = () => {
  store.increment()
}
</script>
```

## 实现核心 Pinia

> pinia/index.js

```js
export { createPinia } from "./createPinia"
export { defineStore } from "./store"
```

### 1.实现 createPinia

> 这是 Pinia 的核心实现,创建 pinia 实例,提供全局状态容器和方法,用于后续创建和管理 stores,实现整个状态管理

1. 创建一个 effect 作用域 scope,用于存储全局状态。
2. 在 scope 内使用 ref 创建一个空的共享状态 state。
3. 创建 pinia 实例,包含多个属性和方法。
4. install 方法在 app 中注册 pinia,提供全局实例,并设置当前激活的实例。
5. state 为全局共享的空状态。
6. use 方法用于使用插件。
7. \_p 存储使用的插件列表。
8. \_a 存储当前的应用实例。
9. \_e 存储共享的 effect 作用域。
10. \_s 存储注册的 stores。
11. 通过 createPinia 创建出 pinia 实例,并在 app 中注册使用。
12. 后续通过 defineStore 注册 store 时会往 state 中添加数据。
13. 通过 provide/inject 方式在全局提供 pinia 实例。

```js
import { ref, effectScope } from "vue"

export const piniaSymbol = Symbol()
export let activePinia
export const setActivePinia = (pinia) => (activePinia = pinia)

export function createPinia() {
  const scope = effectScope()
  // 整个应用的状态稍后defineStore的时候 就会在这里增加状态
  const state = scope.run(() => ref({}))
  let _p = []
  const pinia = {
    install(app) {
      pinia._a = app // 当前应用
      setActivePinia(pinia) // 设置激活pinia
      // 1.在当前应用中暴露pinia实例
      app.provide(piniaSymbol, pinia)
      // 2.optionsAPI可以通过this访问到实例
      app.config.globalProperties.$pinia = pinia
    },
    state,
    use(plugin) {
      //  使用插件
      _p.push(plugin)
      return //可以链式调用
    },
    _p, //记录使用的插件
    _a: null, //记录当前的app
    _e: scope, // 当前作用域
    _s: new Map(), // 记录有哪些store的
  }
  return pinia
}
```

### 2.实现 defineStore

> defineStore 是 Pinia 的核心方法，用来定义一个新的 store 并返回获取该 store 的函数。它会在 pinia 中注册该 store，并管理 store 的创建。调用 defineStore 得到的 useStore 函数可以用来在组件中获取并使用该 store。
>
> 这样实现了存储的模块化注册,以及通过 useStore 组合式获取 store 实例。是 Pinia 状态管理的关键。

1. 从参数中提取 store 的 id 和 options。
2. 定义 useStore 函数,用于获取 store 实例。
3. 在 useStore 中,通过 pinia 实例获取 store。
4. 如果 store 未创建,会根据传入的 setup 或 options 创建新的 store。
5. createSetupStore 和 createOptionsStore 分别处理 setup store 和 options store。
6. 创建好的 store 会存入 pinia.\_s 中。
7. useStore 函数返回已经创建的 store 实例。
8. 给 useStore 添加 $id 属性,绑定 store id。
9. defineStore 返回 useStore 函数。

```js
export function defineStore(idOrOptions, setup, setupOptions = {}) {
  // id从字符串或配置对象中提取
  let id
  let options
  const isSetupStore = typeof setup === "function"
  // 根据情况分别设置id和options
  if (typeof idOrOptions === "string") {
    id = idOrOptions
    options = isSetupStore ? setupOptions : setup
  } else {
    options = idOrOptions
    id = idOrOptions.id
  }
  // 定义useStore函数
  function useStore() {
    // 判断是否存在pinia上下文环境
    const hasContext = hasInjectionContext()
    // 从context中读取 pinia 实例
    // 只能在组件中使用
    let pinia = hasContext && inject(piniaSymbol)
    if (pinia) setActivePinia(pinia)
    pinia = activePinia
    // 如果该store尚未创建
    if (!pinia._s.has(id)) {
      // 根据情况创建store,存储到_s中
      if (isSetupStore) {
        createSetupStore(id, setup, {}, pinia, true) // 创建setupStore
      } else {
        createOptionsStore(id, options, pinia, false) // 创建选项store
      }
    }
    // 取出已创建的store返回
    const store = pinia._s.get(id)
    return store
  }
  // 给函数绑定store的id
  useStore.$id = id
  // 返回useStore函数
  return useStore
}
```

### 3.创建 setupStore

> 这样通过 effect 作用域和 reactive,实现了 setup 语法的 Pinia store 定义方式,同时添加了 actions 支持。
> 并通过 pinia 管理所有的 stores。这是 Pinia 中实现组件化状态管理的核心机制。

1. 创建一个新的 effect 作用域 scope,用于隔离这个 store 的状态。
2. 定义一个 wrapAction 方法,用于包装 actions 函数,改变 this 指向 store 本身。
3. 创建一个 partialStore 对象,包含 pinia 实例和 id 信息。
4. 使用 reactive 将 partialStore 转换成响应式。
5. 在 pinia.\_e 作用域内运行 setup 函数,返回初始化的状态。
6. 使用 for 循环遍历 setupStore,如果是函数就用 wrapAction 包装成 action。
7. 使用 Object.assign 将 setupStore 合并到 store 中。
8. 将定义好的 store 保存到 pinia 的 store 容器 pinia.\_s 中。
9. 返回创建好的 store 实例。

```js
function createSetupStore($id, setup, options, pinia, isSetupStore) {
  let scope
  //处理action 修改this指向
  function wrapAction(name, action) {
    // action
    return function () {
      let ret = action.apply(this, arguments) // 让this指向store
      return ret
    }
  }

  const partialStore = {
    _p: pinia,
    $id,
  }

  let store = reactive(partialStore)
  const setupStore = pinia._e.run(() => {
    scope = effectScope() // 需要开辟一个空间，来管理此store中的数据
    return scope.run(() => setup()) // 这个setup方法就是用来初始化store中的状态的
  })
  //overwrite existing actions to support $onAction
  for (const key in setupStore) {
    const prop = setupStore[key]
    if (typeof prop === "function") {
      // 对action进行一次包装
      setupStore[key] = wrapAction(key, prop)
    }
  }
  Object.assign(store, setupStore) // 合并选项

  pinia._s.set($id, store) // 放入到容器中
  return store
}
```

### 4.创建 optionsStore

1. 按照传统的 options 方式定义状态、getter、action。
2. 在 setup 中合并不同选项到一起。
3. 通过 createSetupStore 最终创建 store。

```js
function createOptionsStore(id, options, pinia, isSetupStore) {
  let store
  //1. 从 options 中解构出 state、getters、actions。
  const { state, getters = {}, actions = {} } = options
  //2. 定义 setup 函数,用于初始化 store。
  function setup() {
    //3. 把状态 state 保存到 pinia 的共享状态中。
    pinia.state.value[id] = state ? state() : {}
    //4. 使用 toRefs 将state变成响应式
    const localState = toRefs(pinia.state.value[id])
    // 5. state、actions、getters 合并到一起返回。
    return Object.assign(
      localState,
      actions,
      //6. getters 通过 computed 转换成计算属性访问。
      Object.keys(getters).reduce((gettersObj, getterName) => {
        gettersObj[getterName] = computed(() => {
          return getters[getterName].call(store)
        })
        return gettersObj
      }, {})
    )
  }
  // 7. 使用 createSetupStore 创建 store,传入 setup。
  store = createSetupStore(id, setup, options, pinia, isSetupStore)
  //8. 返回创建的 store。
  return store
}
```
